-- Лампочки.

-- = Система =

-- Дано квадратное поле 4х4. В каждой ячейке поля есть лампочка. Три игрока по очереди переключают лампочки (переключить: если была выключена, то зажечь, иначе выключить).
-- Первый игрок выбирает лампочку и переключает её и все соседние по вертикали и горизонтали, если они есть. После первого игрока ходит второй.
-- Второй игрок выбирает лампочку и переключает её и все соседние по вертикали, горизонтали и диагонали, если они есть. После второго игрока ходит третий.
-- Третий игрок выбирает лампочку и переключает её, а также две соседние слева и две соседние справа, если они есть. Кроме того, третий игрок решает, какой из первых двух игроков ходит следующим.

-- Начальная раскладка: все лампочки выключены.

-- = Свойства =

-- 1. Игроки могут зажечь все лампочки.
-- 2. Игроки могут зажечь все лампочки так, чтобы правая верхняя лампочка до последнего хода всегда была выключена.
-- 3. Игроки могут зажечь все лампочки, даже если третий игрок всегда выбирает первого следующим.
-- 4. Как бы игроки ни выбирали лампочки до текущего момента, они обязательно имеют возможность продолжить выбирать лампочки так, чтобы зажечь их все.


MODULE main
VAR 
    field: array 0..2 of array 0..2 of boolean;
    player: {first, second, third};
    i: 0..2;
    j: 0..2;
    j-1: 0..1;
    jp1: 1..2;
    i-1: 0..1;
    ip1: 1..2;
    j-2: 0..0;
    jp2: 2..2;
    
    
INIT 
    
    !field[0][0] & !field[0][1] & !field[0][2] & --!field[0][3] &
    !field[1][0] & !field[1][1] & !field[1][2] & --!field[1][3] &
    !field[2][0] & !field[2][1] & !field[2][2] & --!field[2][3] &
    --!field[3][0] & !field[3][1] & --!field[3][2] & !field[3][3] &
    player = first &
    (
        case 
            i = 0 : (i-1 = 0) & (ip1 = 1);
            i = 1 : (i-1 = 0) & (ip1 = 2);
            i = 2 : (i-1 = 1) & (ip1 = 2);
        esac
    )& 
    (
        case 
            j = 0 : (j-1 = 0) & (j-2 = 0) & (jp2 = 2) & (jp1 = 1);
            j = 1 : (j-1 = 0) & (j-2 = 0) & (jp2 = 2) & (jp1 = 2);
            j = 2 : (j-1 = 1) & (j-2 = 0) & (jp2 = 2) & (jp1 = 2);
        esac
    ) 
    ;
TRANS
    (   
        
        (((next(player) = second) & (player = first)) | 
        ((next(player) = third) & (player = second)) | 
        (((next(player) = second) | (next(player) = first)) & (player = third))) 
    ) &
    (next(field[i][j]) = !field[i][j]) &
    
    ((0 > j - 1) | (0 <= j - 1) & (next(field[i][j-1]) = !field[i][j-1])) &
    ((2 < j + 1) | (2 >= j + 1) & (next(field[i][jp1]) = !field[i][jp1])) &

    (
        ((player = first) | (player = second)) & 
        (
            ((0 > i - 1) | (0 <= i - 1) & (next(field[i-1][j]) = !field[i-1][j])) &
            ((2 < i + 1) | (2 >= i + 1) & (next(field[ip1][j]) = !field[ip1][j]))
        ) |
     (player = second) & 
        (
            (!((0 <= j - 1) & (0 <= i - 1)) | (0 <= j - 1) & (0 <= i - 1) & (next(field[i-1][j-1]) = !field[i-1][j-1])) &
            (!((i + 1 <= 2) & (j - 1 >= 0)) | (i + 1 <= 2) & (j - 1 >= 0) & (next(field[ip1][j-1]) = !field[ip1][j-1])) &
            (!((i - 1 >= 0) & (j + 1 <= 2)) | (i - 1 >= 0) & (j + 1 <= 2) & (next(field[i-1][jp1]) = !field[i-1][jp1])) &
            (!((i + 1 <= 2) & (j + 1 <= 2)) | (i + 1 <= 2) & (j + 1 <= 2) & (next(field[ip1][jp1]) = !field[ip1][jp1])) 
        ) |
     (player = third) & 
        (
            ((0 > j - 2) | (0 <= j - 2) & (next(field[i][j-2]) = !field[i][j-2])) &
            ((2 < j + 2) | (2 >= j + 2) & (next(field[i][jp2]) = !field[i][jp2]))
        )
    );











    -- (next(i) != i) & (next(j) != j) ;
    
    
       
    
    -- &

    -- (0 <= i) & (i <= 4) & 
    -- (0 <= j) & (j <= 4);
-- CTLSPEC AG b;
-- CTLSPEC AG (!b -> AX b);

-- read_model
-- flatten_hierarchy
-- encode_variables
-- build_model
-- pick_state -i -a
-- print_current_state -v
-- simulate -i -k 5






-- EXAMPLE
-- MODULE main
-- VAR b: boolean;
-- INIT b;
-- TRANS next(b) = !b;
-- CTLSPEC AG b;
-- CTLSPEC AG (!b -> AX b);








-- NuSMV/bin/NuSMV